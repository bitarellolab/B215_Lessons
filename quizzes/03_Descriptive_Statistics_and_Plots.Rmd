---
title: "Descriptive Statistics and Plots"
output: 
  learnr::tutorial:
    progressive: TRUE
    allow_skip: FALSE
runtime: shiny_prerendered
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
library(learnr)
library(tidyverse)
library(knitr)
library(ggmosaic)
library(praise)
library(utils)
library(datasets)
library(dplyr)
tutorial_options(exercise.eval = TRUE, exercise.reveal_solution = FALSE)
gradethis::gradethis_setup(
  pass.praise = TRUE,
  fail.encourage = TRUE,
  fail.hint = TRUE
)

```

## Overview

Tasks: 

-   Work through this document

Learning outcomes: 

1.  Summary statistics

2.  Learn how to perform routine data wrangling tasks with `dplyr` core functions: `filter`, `select`, `mutate`, `arrange`, `transmute`, `summarise`

3.  Pipe `%>%` these operations together.

4.  Be able to suggest improvements to basic graphs to improve readability and accurate communication

5.  Explain the idea of mapping data onto aesthetics, and the use of different `geoms`

6.  Match common plots to common data type.


## Reading in data and dealing with missing data

### Read in data

You can import many types of data in R. If you want to see which file types are possible to read in from base R, type "read" in the console and then hit tab. That will show you all the various types of read functions for different file types inherent to base R.

Here, we'll be using read.csv which reads... csv files.

```{r, echo=T, eval=F}
titanicdata <- read.csv("C:/Users/levir/Documents/GitHub/B215_Lessons/Lab3/rstudio-export_lab3/data/titanic.csv")

```


```{r setupnum}
titanicdata <- read.csv("C:/Users/levir/Documents/GitHub/B215_Lessons/Lab3/rstudio-export_lab3/data/titanic.csv")
```

Sometimes, real world data sucks. It's missing entries, or it mixes data class types (e.g., a column that appears to be numeric, but is actually a sneaky character vector). For that reason, you always should inspect your data before you do any stats. For small files, view("r object") can be used, but for larger files, opening an r object can be prohibitively slow. You have already learned a function to call the first six rows of a dataset: head. Call it here and inspect the object titanicdata. This data both refers to the titanic and is, itself, titanic and therefore head is appropriate.
```{r examplenum, exercise = TRUE, exercise.setup = "setupnum"}
                    
```


```{r examplenum-solution}
head(titanicdata)

```

```{r examplenum-check}
grade_this_code()
```

## Summary statistics and missing data!

Now look at age by selecting the column `age` in the `titanicdata` object and printing out that column:
```{r examplenum1, exercise = TRUE, exercise.setup = "setupnum"}
                    
```


```{r examplenum1-solution}
print(titanicdata$age)

```

```{r examplenum1-check}
grade_this_code()
```

If you look through the results, you will see that most individuals have numbers in this list, but some have NA. These NAs are the people for which we do not have age information.

By the way, the `titanic.csv` file simply has nothing in the places where there is missing data. When R loaded it, it replaced the empty spots with NA automatically.

We have already seen in lab 2 how to calculate the mean of a vector of data using `mean()`. Unfortunately, if there are missing data we need to tell R how to deal with it.

A (somewhat annoying) quirk of R is that if we try to take the mean of a list of numbers that include missing data, we get an NA for the result!


```{r}
mean(titanicdata$age)
```

To get the mean of all the numbers that we do have, we have to add an option to the mean() function. This option is `na.rm = TRUE`:


```{r}
mean(titanicdata$age, na.rm = T)
```

Many other functions have this "na.rm = T" option, but for those that don't, you will have to do some data cleaning, which we will learn how to do shortly.

Try this with the function for standard deviation: sd()

```{r examplenum2, exercise = TRUE, exercise.setup = "setupnum"}
                    
```


```{r examplenum2-solution}
is.na(titanicdata$age)

```

```{r examplenum2-check}
grade_this_code()
```

SD is one way to measure variance and deviation but there are others!

Try calculating the variance of the age data using the implemtation in r: var()
```{r examplenum3, exercise = TRUE, exercise.setup = "setupnum"}
                    
```


```{r examplenum3-solution}
var(titanicdata$age, na.rm = T)

```

```{r examplenum3-check}
grade_this_code()
```

If you notice, variance is just SD squared. Or. SD is just variance square rooted.

Other metrics of variation include the coefficient of variation. Surprisingly, there is no standard function in R to calculate the coefficient of variation. You can do this yourself, though, directly from the definition:

```{r}
100 * sd(titanicdata$age, na.rm = TRUE) / mean(titanicdata$age, na.rm = TRUE) 

```

Make sure you understand the command above before continuing!

Other metrics include range and interquartile range which are the differnece between the max and the min points in the data and the third quartile and first quartile in the data respectively. You can call these functions as range() and IQR() in the exact same format as mean() and sd().

### Missing data

Lets say you are trying to do a statistical test which lacks na. rm capabilities? Well, it's pretty simple:
```{r}
titanicdata2<-na.omit(titanicdata)
```

We can confirm that the missing rows have been deleted by comparing the number of rows in titanicdata2 with titanic data:
```{r}
nrow(titanicdata)-nrow(titanicdata2)
```

680 rows with missing data! But did this function actually remove all the rows with missing data or did it mess up? 

Well, three functions are useful for us to decide. length, which returns the number of entries, which, and is.na, which returns a logical statement stating whether any entry in the input is NA.

Try testing whether there are any NAs in titanicdata$age (which, becuase we know there are, should return TRUE)
```{r examplenum4, exercise = TRUE, exercise.setup = "setupnum"}
                    
```


```{r examplenum4-solution}
var(titanicdata$age, na.rm = T)

```

```{r examplenum4-check}
grade_this_code()
```

Now, since we know that there are NAs in the age column, try finding out which rows in titanicdata contain NAs
```{r examplenum5, exercise = TRUE, exercise.setup = "setupnum"}
                    
```


```{r examplenum5-solution}
which(is.na(titanicdata$age))

```

```{r examplenum5-check}
grade_this_code()
```

This should return a big list of row numbers and, finally, we can take the length of this result and if it equals 680, we will know that na.omit worked:
```{r examplenum6, exercise = TRUE, exercise.setup = "setupnum"}
                    
```


```{r examplenum6-solution}
length(which(is.na(titanicdata$age)))

```

```{r examplenum6-check}
grade_this_code()
```


## Quiz Part 2: Working with real data



Now we are going to practice working with an actual data set. We will be using one from the datasets package called chickweights. It's from an experiment on the effect of diet on early growth of chicks. If you want to learn more about the dataset type ??chickweights into your console. 

### Lets look at the data
The datasets package already has the data stored as a data frame. If it wasn't you could call data.frame to turn it into one. Rename the data chicks by assigning the code already loaded to that name. 
It's long, so we don't want to print the whole thing. Use a specific function to call just the first 6 rows.

```{r chicks1, exercise = TRUE}
datasets::ChickWeight

```


```{r chicks1-solution}
chicks<-datasets::ChickWeight
head(chicks)
```

```{r chicks1-check}
grade_this_code()
```

### Analyzing the data
Lets see which diet worked best! This data shows us the same chicken at multiple times. If we only want to see the final outcome, we can filter for the final weight. Using the dplyr filter function to select only chicks with time 21.
name this resulting dataframe FinalChicks. Then print it. 
```{r setupchicks}
chicks<-datasets::ChickWeight
FinalChicks<-filter(chicks, Time == "21")


```



```{r chicks2, exercise = TRUE, exercise.setup = "setupchicks"}

```


```{r chicks2-solution}
FinalChicks<-filter(chicks, Time == "21")
print(FinalChicks)
```

```{r chicks2-check}
grade_this_code()
```


Now lets get the mean for each diet. Use the pattern below calculate the mean weight for the chicks in each of the 4 diets. 

```{r chicks3, exercise = TRUE, exercise.setup = "setupchicks"}
diet1<-filter(FinalChicks, Diet == "1")
mean(diet1$weight)

```


```{r chicks3-solution}
diet1<-filter(FinalChicks, Diet == "1")
mean(diet1$weight)

diet2<-filter(FinalChicks, Diet == "2")
mean(diet2$weight)

diet3<-filter(FinalChicks, Diet == "3")
mean(diet3$weight)

diet4<-filter(FinalChicks, Diet == "4")
mean(diet4$weight)

```

```{r chicks3-check}
grade_this_code()
```



Isn't that a lot of work to get 4 simple means? Next week you are going to learn how to do all that in one go! Here's how you'd do it. Print the dataframe from this code to see how fast it is!

```{r chicks4, exercise = TRUE, exercise.setup = "setupchicks"}
avg_chick_wgts<- chicks %>%
filter(Time == "21") %>% 
group_by(Diet) %>%
summarize(mean_weight = mean(weight, na.rm = TRUE))
```


```{r chicks4-solution}
avg_chick_wgts<- chicks %>%
filter(Time == "21") %>% 
group_by(Diet) %>%
summarize(mean_weight = mean(weight, na.rm = TRUE))

print(avg_chick_wgts)
```

```{r chicks4-check}
grade_this_code()
```
