---
title: "Lesson 7-Key!"
author: "YOUR NAME"
date: "`r Sys.Date()`"
output: pdf_document
header-includes:
  \usepackage{fvextra}
  \DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\{\}}
---
```{r setup, echo=F}
knitr::opts_chunk$set(echo=T, eval=T)
options(tinytex.verbose = TRUE)
suppressMessages(library(dplyr))
```


## Learning goals

* Using R's built-in loop functions: `apply`, `lapply` and contrasting them with `for` loops

* Conditional statements

* Investigate sampling error

* Visualize confidence intervals.

* Adding error bars to plots







## Apply and lapply

Last week you learned about loops, which are standard in all programming languages. However, R has some built in functions that perform similar operations and are a bit more simple to use. They belong to the apply family. Here are some differences between apply and lapply
Differences between lapply and apply:
Data Types:

* lapply works on lists and vectors.
* apply works on matrices and arrays.

Return Type:

* lapply always returns a list.
* apply can return a vector, matrix, or array, depending on the function being applied and the input's dimensions.

Use Case:

* Use lapply when you have a list or vector and you want to apply a function to each of its elements.
* Use apply when you have a matrix or array and you want to apply a function across its rows or columns.



There are many other functions in the apply family but we are just focusing on these two.
I recommend typing ? apply and ?lapply into the console before starting. The second argument, margin, can be tricky. 


#### 1. Let's start super basic. Say you have a matrix mat <- matrix(1:12, nrow=3). You want to find the sum of each column. paste the matrix first then use apply to find the sum. Name it something then print the result


```{r ex1}
mat <- matrix(1:12, nrow=3)
column_sums <- apply(mat, 2, sum)
print(column_sums)


```

##### 2. Now you have a list of names. Use lapply to find how many characters are in each name. Save as an object+print
Here are your names, get counting
names_list <- list("Alessandra", "Penelope", "Meigui", "Tatiana", "Keisuke", "Nadia", "Amy")


```{r ex2}

names_list <- list("Alessandra", "Penelope", "Meigui", "Tatiana", "Keisuke", "Nadia", "Amy")
char_count <- lapply(names_list, nchar)
print(char_count)

```
What is different about this output? 
Correct, it's a list



#### 3. Comparing Apply and For loops 


You're a teacher and you've just given your students a test. The test scores are stored in a matrix where each row represents a student and each column represents a test question. Calculate the average score for each student using both apply and a for loop. 
Your matrix is called scores and has all the information you need. 



```{r setupex3}
scores <- matrix(c(85, 90, 78, 88, 
                   92, 80, 95, 90, 
                   60, 55, 78, 84), 
                 nrow=3, byrow=TRUE)
colnames(scores) <- c("Math", "English", "Biology", "History")
rownames(scores) <- c("Alice", "Bob", "Charlie")



```


First use the new functions you learned to find the average test score for each student. 



```{r. ex3.1 }
averages_apply <- apply(scores, 1, mean)


```

Now use a for loop. remember to create blank variables first to store your information



```{r ex3.2 }
num_students <- nrow(scores)
averages <- numeric(num_students)

for (i in 1:num_students) {
  averages[i] <- mean(scores[i,])
}

names(averages) <- rownames(scores)



```



Which of these was easier for you? Which student is doing the best?


Which class do you think is hardest? Lets do the process again to find the average for each class
First use apply
```{r. ex3.3 }

class_averages_apply <- apply(scores, 2, mean)


```

Then use a loop

```{r ex3.4}


num_subjects <- ncol(scores)
class_averages <- numeric(num_subjects)

for (j in 1:num_subjects) {
  class_averages[j] <- mean(scores[,j])
}

names(class_averages) <- colnames(scores)

```


And now you understand the joy of the apply family. 

## Conditional Statements
Conditional Statements are a key part of any programming language. 
1. if Statement:
The if statement evaluates a condition, and if that condition is TRUE, it executes the code inside the statement.
For each of these change x to a few different numbers to see how the output changes!

```{r }
x <- 10

if (x > 5) {
  print("x is greater than 5")
}


```

In the above code, since x is indeed greater than 5, the message "x is greater than 5" will be printed.

2. if-else Statement:
There might be cases where you want to execute one set of instructions if the condition is TRUE and another set if it's FALSE. This is where the if-else statement comes in.



```{r}
x <- 3

if (x > 5) {
  print("x is greater than 5")
} else {
  print("x is not greater than 5")
}

```

You can keep adding else statements!

3. if-else if-else Ladder:
For multiple conditions, we can use an if-else if-else ladder.


```{r}
x <- 5

if (x > 10) {
  print("x is greater than 10")
} else if (x > 5) {
  print("x is greater than 5 but less than or equal to 10")
} else {
  print("x is less than or equal to 5")
}

```

And so on and so on. This is really useful for making code do complicated things!

##### 4. 
Write a basic if statement that prints "this number is positive" when that is true. Try some numbers!


```{r ex4.1}
number <-3

if (number > 0) {
  print("The number is positive.")
}


```



Now add an else if statement that tells you if the number is negative, and an else that tells you if its 0.

```{r ex4.2}

number <-3


if (number > 0) {
  print("The number is positive.")
} else if (number < 0) {
  print("The number is negative.")
} else {
  print("The number is zero.")
}

```


Amazing! You now understand basic conditionals! Let's combine this with loops. Here is an example of a loop that contains an if statement 
Lets say you have a bunch of numbers and you want to know how many are positive. 


```{r}
numbers <- c(-5, 3, 8, -2, 0, 7, -9)

positive_count <- 0
for (num in numbers) {
  if (num > 0) {
    positive_count <- positive_count + 1
  }
}

```

This loop adds one to the count for each positive number.

#### 5. Now I gave you a bunch of random numbers. Write a loop telling me the sum of all the even numbers.

```{r ex5}

numbers <- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

sum_even <- 0
for (num in numbers) {
  if (num %% 2 == 0) {
    sum_even <- sum_even + num
  }
}


```


## More work in sampling
Now we are going to return to our example from last class, the human genes data set. We are going to graph more sampling distributions and add error bars to some plots. 


#### 6. Last class we compared the means of differently sized samples. Generally, the larger your sample, the closer it will be to the true population mean. The human gene data set is a bit weird though. Because it has a few genes that are huge, a large sample size might be more likely to include one of those giant genes and mess up your mean. For a real experiment you would just deal with that. For our purposes, you should filter the data set to only include genes smaller than 15000 base pairs. Load in your data and do this. You can keep it's name the same



```{r ex6.1}
library(readr)
human_genes <- read_csv("Documents/GitHub/B215_Lessons/fall_2022_materials/lab7/human_genes.csv")

human_genes <- human_genes %>% filter(size < 15000)



```


Run the loop you wrote last week and invisigate the means now that we have filtered the data. What do you see?


```{r ex6.2}
mean_values_10 <- numeric(100)
mean_values_100 <- numeric(100)
mean_values_1000 <- numeric(100)

for (i in 1:100) {
  mean_values_10[i] <- mean(sample(human_genes$size, 10, replace = TRUE))
  mean_values_100[i] <- mean(sample(human_genes$size, 100, replace = TRUE))
  mean_values_1000[i] <- mean(sample(human_genes$size, 1000, replace = TRUE))
}


```

#### 7. What's up with these samples?


Start by finding the standard error of the mean, which is your sample standard deviation divided by the square root of your sample size. Do this for each sample size. 

```{r ex7.1}

sem_10<-sd(mean_values_10)/sqrt(length(mean_values_10))
sem_100<-sd(mean_values_100)/sqrt(length(mean_values_100))
sem_1000<-sd(mean_values_1000)/sqrt(length(mean_values_1000))


```

Now lets find the 95% confidence intervals. Type ?quantile into your console to learn how to use this neat function. 
Hint: We want 95% of the data to be within the intervals, so what should the quantile be?

```{r ex7.2}

CI_10 <- quantile(mean_values_10, probs = c(0.025, 0.975))
CI_100 <- quantile(mean_values_100, probs = c(0.025, 0.975))
CI_1000 <- quantile(mean_values_1000, probs = c(0.025, 0.975))

```


Now we have these confidence intervals. Lets add them to a graph. 



#### 8. Graph.

Lets first make a data frame of all the information we will need for the chart. You need the following columns: SampleSize, MeanValues, UpperCI and LowerCI. You can use the ones you've calculated but don't rerun your code if you type the actual values unless you've set a seed!


```{r ex8.1}


data <- data.frame(
  SampleSize = c(10, 100, 1000),
  MeanValues = c(mean(mean_values_10), mean(mean_values_100), mean(mean_values_1000)),
  CI_lower = c(CI_10[1], CI_100[1], CI_1000[1]),
  CI_upper = c(CI_10[2], CI_100[2], CI_1000[2])
)


```


Amazing! Now make a box plot using this data frame. Don't worry about CI yet. Just make a simple box plot. Add labels and colors though. 


```{r ex8.2}
ggplot(df, aes(x = as.factor(SampleSize), y = MeanValues)) +
  geom_bar(stat = "summary", fun = "mean", fill = "skyblue", position = position_dodge(width = 0.9)) +
  labs(
    title = "Sampling Distributions of Different Sample Sizes",
    x = "Sample Size",
    y = "Mean Value",
    fill = "Sample Size"
  ) +
  theme_minimal()


```

Gorgeous. Now add your error bars. Use geom_errorbar to see the difference in those sample sizes

```{r ex8.3}

ggplot(df, aes(x = as.factor(SampleSize), y = MeanValues)) +
  geom_bar(stat = "summary", fun = "mean", fill = "skyblue", position = position_dodge(width = 0.9)) +
  geom_errorbar(aes(ymin = CI_lower, ymax = CI_upper), width = 0.2, position = position_dodge(width = 0.9)) +
  labs(
    title = "Sampling Distributions of Different Sample Sizes",
    x = "Sample Size",
    y = "Mean Value",
    fill = "Sample Size"
  ) +
  theme_minimal()


```

Those are super different! As you can see, larger sample sizes create smaller errors. This is important for your own data analysis. 


#### 9. Another graph
What do these samples look like compared to a normal distribution? R has a built in plot (gasp it's not ggplot2) called a density plot that will show us. 
First, use the density function to find the density of each of your sample means. Name them something you'll remember.


```{r 9.1}
dense10<-density(mean_values_10)
dense100<-density(mean_values_100)
dense1000<-density(mean_values_1000)

```

Now use the R function "plot" to plot each of these. 

```{r}

plot10<-plot(dense10, main = "Density Plot of Sample Means, n=10", xlab = "Sample Mean")
plot100<-plot(dense100, main = "Density Plot of Sample Means, n=100", xlab = "Sample Mean")
plot1000<-plot(dense1000, main = "Density Plot of Sample Means, n=1000", xlab = "Sample Mean")


```

You see as the n increases they get more normal!

