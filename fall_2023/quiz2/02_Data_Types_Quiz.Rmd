---
title: "Data types and Data Structures"
output: 
  learnr::tutorial:
    progressive: TRUE
    allow_skip: TRUE
runtime: shiny_prerendered
date: "`r Sys.Date()`"
tutorial:
  id: "b215.f23.lab2.test10"
  version: 2.3
---

```{r setup, include=FALSE}
library(devtools)
library(learnr)
library(submitr)
library(gradethis)
library(tidyverse)
library(knitr)
library(ggmosaic)
library(praise)
library(utils)
library(dplyr)
library(basket)


learnr::tutorial_options(exercise.eval = TRUE, 
                         exercise.reveal_solution = FALSE, 
                         exercise.timelimit = 30,
                         exercise.checker = gradethis::grade_learnr,
)


gradethis::gradethis_setup(
  pass.praise = TRUE,
  fail.encourage = TRUE,
  fail.hint = TRUE
)


#https://stackoverflow.com/questions/51778262/how-can-i-record-exercise-submission-in-a-learnr-r-tutorial
#
#new_recorder <- function(tutorial_id, tutorial_version, user_id, event, data) {
#    cat(tutorial_id, " (", tutorial_version, "): ", user_id, ", ", event, ", ", #data$label, ", ", data$answers, ", ", data$correct, "\n", sep = "", file="test2.txt", #append=TRUE)
#}

#options(tutorial.event_recorder = new_recorder)
#
tutorial_event_recorder <- function(tutorial_id, tutorial_version, user_id, event, data) {
  
    data_names <- c("label", "question", "answer", "code")
    data_in_standard_format <- list()
    data_in_standard_format[data_names] <- NA
    actual_names <- intersect(data_names, names(data))
    data_in_standard_format[actual_names] <- data[actual_names]
    

# Data : User and Email
  this_event <- data.frame(time = lubridate::with_tz(Sys.time(), "America/New_York"), 
                 user_id = user_id,
                #email = NA,
                 event = event, 
                 correct  = ifelse(is.null(data$correct), NA, data$correct),
                 feedback = ifelse(is.null(data$feedback$correct), NA, data$feedback$correct), 
                 stringsAsFactors = FALSE)
  
      sam <- cbind(this_event, data_in_standard_format)
      out_file<-"test5.txt"
      if(file.exists(out_file)){
              colnamesYN<-FALSE
              appendYN<-TRUE
      }else{
              colnamesYN<-TRUE
              appendYN<-FALSE
      }
     #sam<-data.table::setDT(sam)
      data.table::fwrite(sam[,c(1,2,3,4,6)], file=out_file, sep="\t", col.names = colnamesYN, append = appendYN)
      print(sam)
      #saveRDS(data,"data.Rds", append=ifelse(file.exists("data.Rds"), T, F))
}
options(tutorial.event_recorder = tutorial_event_recorder)
```

```{r context = "server", echo = FALSE}
#options(tutorial.event_recorder = my_event_recorder)
#options(tutorial.storage = "none")
#vfun <- make_basic_validator(psfile=".cred/credentials.txt", instructor_secret="mortadela")

#storage_actions <- 
#  record_gs4(
#    key = "1GZK3mkBTk0y4dsPu3vuZMd_wcvdShvTNoyJWJwqmG8k",
#    email = "bbitarello.teaching@gmail.com",
#    vfun
#)

#storage_actions <- record_local("lab2_record.txt")
#submitr::shiny_logic(input, output, session, vfun,
#                     storage_actions)
```

```{css echo=FALSE}
 @media print {
  .topicsContainer,
  .topicActions,
  .exerciseActions .skip {
    display: none;
  }
  .topics .tutorialTitle,
  .topics .section.level2,
  .topics .section.level3:not(.hide) {
    display: block;
  }
  .topics {
    width: 100%;
  }
  .tutorial-exercise, .tutorial-question {
    page-break-inside: avoid;
  }
  .section.level3.done h3 {
    padding-left: 0;
    background-image: none;
  }
  .topics .showSkip .exerciseActions::before {
    content: "Topic not yet completed...";
    font-style: italic;
  }
}
/* paste CSS above here */
```

## Overview

Tasks:

-   Work through this document
-   Complete DataCamp assignments on data types and data structures
-   Practice, practice, practice!

## Learning outcomes

1.  Learn about the different types of data: numeric, integer, logical, character, factor, etc.

2.  Understand the importance of the `NA` values in R.

3.  Familiarize yourselves with common types of data structures: vectors, matrices, data.frames, lists

4.  Understand the interactions between vectors and matrices

5.  Indexing vectors, matrices, data.frames, lists

## Data types & Data structures- Why??

This sounds boring and intimidating. Why do we need this? Well, these are fundamental concepts in programming, and they transcend R -- they apply to any programming language.

-   **Data types** define the kind of data that a variable can hold and the operations that can be performed on that data.

-   **Data structures** are ways to organize and store data in a structured and efficient manner within a computer program. They allow you to group and manage related pieces of data together. Think of data structures as containers that hold data in specific formats to make it easier to work with that data.

## Data types: How many ways can data be formatted

Data types help the computer interpret and manipulate the data correctly.

In R:

-   The five main ones: Numeric, integer, logical, character, factor
-   Extras: date, complex, raw

### Numeric

This is the default computational data type in R. If you enter a number without a decimal point, R will automatically convert it into a numeric data type. Numeric values in R can hold any real number, including both integers and fractions, and even negative numbers. For example, 5, 23.5, and -3 are all numeric values.

```{r, echo=T, eval=F}
pi <- 3.14
print(pi)
class(pi)
is.numeric(pi)
is.integer(pi)
```

Try these out here:

```{r sandbox, exercise=TRUE, eval = FALSE}

```

### Integer

This data type in R is used to hold whole numbers. Unlike numeric values, integers cannot have a decimal point. You can create an integer in R by adding an 'L' suffix to a number, like this: 5L. Without the 'L', R would treat the number as numeric, not integer.

```{r, echo=T, eval=F}
class_number <- 215L
class(class_number)
is.integer(class_number)
is.numeric(class_number)
```

Sometimes you can convert one type into another. Say numeric to integer or vice-versa:

```{r, echo=T, eval=F}
class_number <- 215
class(class_number)
new_class_number<-as.integer(class_number)
class(new_class_number)
```

Try these out here:

```{r sandbox2, exercise=TRUE, eval = FALSE}

```

### Logical (T/F)

Logical data type in R is used to hold Boolean values: TRUE or FALSE. You can use logical operators like \<, \>, ==, etc. to generate logical values. For example, the operation 5 \> 3 will return TRUE because 5 is indeed greater than 3. You can also store TRUE or FALSE values in variables or vectors as you would with the numerical values we have already seen.

```{r, echo=T, eval=F}
reality <- TRUE
reality2 <- T #also works
isTRUE(reality)
isFALSE(reality2)
```

Try these out here:

```{r sandbox3, exercise=TRUE, eval = FALSE}

```

### Character

Character data type in R is used to hold strings of text. You can create a character string by enclosing text in quotes. For example, "Hello, World!" is a character string.

```{r, echo=T, eval=F}
types_of_data <- c("Numeric", "Interger","Logical", "Complex", "Character", "Raw") 
class(types_of_data)
is.character(types_of_data)
```

Try these out here:

```{r sandboxchar, exercise=TRUE, eval = FALSE}

```

### Factor

Factors are great for storing **categorical variables**. An example you might encounter in the world of bioinformatics is different species you want to compare. For this example, let's look at the different hominin (early human) genuses. 

You could start off with a vector that lists each genus.

```{r, echo=T, eval=F}
hominin_genus <- c("Ardipithecus", "Australopithecus", "Homo", "Paranthropus", "Sahelanthropus")
length(hominin_genus) #check that there are 5 elements
class(hominin_genus) #check that class so far is character

```

And now you could convert this into a factor, since it is clearly a categorical variable.

```{r setupmls}
hominin_genus <- c("Ardipithecus", "Australopithecus", "Homo", "Paranthropus", "Sahelanthropus")
hominin_genus_factor<-as.factor(hominin_genus)

```

```{r echo=T, eval=F}
hominin_genus_factor<-as.factor(hominin_genus)
class(hominin_genus_factor)
print(hominin_genus_factor)
```

Try these out here:

```{r sandboxfact, exercise=TRUE, eval = FALSE, , exercise.setup="setupmls"}


```

You will notice that printing `hominin_genus_factor` will spit out the vector, followed by `5 Levels: Ardipithecus Australopithecus ... Sahelanthropus`.

What this means is that the function `as.factor` converted our simple character vector into a data type that is better equipped at handling categorical variables. The "levels" are the different categories observed in the data. Same of the advantages of this will become clearer later on (next week) when we start plotting things and summarizing them. Although we used character data to make our categories here, you could also treat numerical or integer data as factors. For example, in biological testing, you might treat different numbered trials in an experiment as factors.

## Why choose a certain data type?

### Example 1: character

As mentioned, the data type defines the types of operations that can be done with the data. You wouldn't want to (gasp) take the mean of a vector of characters such as `c("mom","Australia", "bologne")`.

Actually, try that and see what happens. Use the function `mean` on the vector above: `print(mean(c('mom','Australia','bologne')))`:

```{r sandbox4, exercise=T, eval = F}

```

As you can see, R will still try its best at guessing what you're up to. Unable to calculate the mean of such things, it will return a warning and `NA`. When you see NA in R, it means that the data at that point is missing or undefined.

On the other hand, there are things that only make sense for characters. For example, the functions:

-   Concatenation: combining two or more character strings using `paste`.
-   Extracting substrings - e.g. `substr`
-   Calculating string length - e.g. `nchar`

Below is a series of examples that use these string manipulation functions on a line from Friends, "Joey doesn't share food!"

```{r, echo=T, eval=F}
one_element <- "Joey"
another_element <- "doesn't"
yet_another <- "share food!"
my_string<-paste(one_element, another_element, yet_another)
print(my_string) 
nchar(my_string) #24 characters (but only 19 letters)
substr(my_string, start=1, stop=18) #Joey doesn't share
not_a_string<-129032L #an integer
print(paste(one_element, another_element, yet_another, not_a_string)) #converts not_a_string into a string! 
```

Try these out:

```{r sandbox-string, exercise=TRUE, eval = FALSE}

```

As you can see, while pasting an integer and text together might make sense in some contexts, that is only true because the integer ceases to be an integer and becomes a string.

### Example 2: numeric and/or integer

Now let's take a look at some of the ways we might use numeric and integer data. Suppose you are studying the growth rate of a bacterial culture. You have the sizes of the bacterial colonies at different time points and you want to calculate the average growth rate for different strains of bacteria in the same type of medium.

```{r, echo=T, eval=F}
growth_data <- c(0.05,2, 1.5, 1.2, 0.08, 2.5, 0.5) # Sizes of bacterial colonies for different bacterial strains
```

```{r setupnum}
growth_data <- c(0.05,2, 1.5, 1.2, 0.08, 2.5, 0.5)
```

Suppose you want to take the mean and median of these values. Create the variables `avg_growth` and `med_growth` and then print `avg_growth` and `med_growth`:

```{r examplenum, exercise = TRUE, exercise.setup = "setupnum"}
      avg_growth <-
      med_growth <-
```

```{r examplenum-solution}
avg_growth <- mean(growth_data) 
med_growth<- median(growth_data)
print(avg_growth)
print(med_growth)

```

```{r examplenum-check}
grade_this_code()
```

Here are a few more operations that are appropriate for `numeric` and `integer` values:

```{r, echo=T, eval=F}
x<-c(5.2,-7.3, 9.8) #numeric
y<-2L #integer
print(abs(x)) #absolute values
print(median(x)) #median of all values in x
print(x>y)
```

Practice these a bit here:

```{r sandbox5, exercise=TRUE, eval = FALSE}

```

*Important:* If there are `NA` values present, we need to explicitly tell R how to handle them.

```{r, echo=T, eval=F}
x<-c(5.2,-7.3, 9.8, NA)
median(x) #median of all values in x
mean(x)
max(x)
min(x)
```

Try these out here:

```{r sandbox6, exercise=TRUE, eval = FALSE}

```

As you can see, that's not great. Now try the commands above again by adding the parameter `na.rm=TRUE` to the functions `mean`, `median`, `max`, and `min`. E.g. `mean(x, na.rm=T)`. This argument tells R to ignore elements in the vector that are `NA`.

```{r example-with-na-setup}
x<-c(5.2,-7.3, 9.8, NA)
```

```{r example-with-na, exercise=TRUE,exercise.setup="example-with-na-setup"}
#mean
#median
#max
#min
```

```{r example-with-na-solution}
mean(x, na.rm=TRUE) #mean
median(x, na.rm=TRUE) #median
max(x, na.rm=TRUE) #max
min(x, na.rm=TRUE) #min
```

Hopefully you got the same results as you had when the `NA` element was not present!

### Example 3: integer

You are counting the number of cells in different samples under a microscope. This is where integers come into play, as you can't have a fraction of a cell.

Suppose you are studying the growth rate of a fungal culture. With the microscope, you are able to actually count them over time. You have the sizes of the fungal colonies at different time points and you want to calculate the average number of cells you find in your culture over the course of seven days.

```{r, echo=T, eval=F}
cell_counts <- c(100, 200, 150, 175, 225, 122, 270) # Number of cells in different time points (sequential)

```

```{r setupint}
cell_counts <- c(100, 200, 150, 175, 225,  122, 270)
```

Besides using the `mean()` function you can also find the mean in R by hand. To do this, you might start by adding up your total number of cells. You could define a variable `total_cells` where you put in the result of the function `sum` on the vector `cell_counts`. Do that and then print the `total_counts` object:

```{r exampleinteger, exercise = TRUE, exercise.setup = "setupint"}
 
                   
```

```{r exampleinteger-solution}
total_cells <- sum(cell_counts) 
print(total_cells)

```

```{r exampleinteger-check}
grade_this_code()
```

Once again, if your data are plagged with NAs (which is usually the case with real data), you will need to be explicit with R. Below is a version of `cell_counts` that is reflective of the typical missing data we have to deal with. Using the code provided as a model, deal with the NAs properly in the sandbox and find the mean by hand. You'll know you've done it correctly if R returns a number, rather than NA.

```{r, echo=T, eval=F}
cell_counts_withNA<-c(100, 200, 150, 175, NA, 122, 270) #the data with NAs, which you will use below
total_cells <- sum(cell_counts) #step 1 in finding the mean by hand when there are no NAs
total_cells/length(cell_counts) #step 2 in finding the mean by hand when there are no NAs
```

Try these for yourself:

```{r sandbox8, exercise=TRUE, eval = FALSE}

```

### Example 4: characters (again)

In bioinformatics, character strings are often used to represent DNA sequences.

```{r, echo=T, eval=F}
dna_sequences <- c("ATGC", "CGTA", "GATC", "TACG") # DNA sequences

```

This example obviously uses justa few datapoints, but when processing DNA data, biologists may deal with hundreds of sequencing fragments at a time. The volume of data necessitates the use of a computer. Here we will practice working with this character data. Suppose you want to look at the first sequence from a long list. You can select an element from vectors (also called indexing) in R by using square brackets after the name of the list, with the number inside the brackets indicating the which number value you are interested in. Paste the following code to define a character variable containing the first sequence in the list and then print it. `first_sequence <- dna_sequences[1] # DNA sequence`:

```{r setupchr}
dna_sequences <- c("ATGC", "CGTA", "GATC", "TACG") # DNA sequences


```

```{r examplechr, exercise = TRUE, exercise.setup = "setupchr"}
  #create first_sequence                  
  #print it
```

```{r examplechr-solution}
first_sequence <- dna_sequences[1] # Get the first DNA sequence
print(first_sequence)

```

```{r examplechr-check}
grade_this_code()
```

Now to get the last element, you could of course extract that with `dna_sequences[4]`. In this easy case, we know from visual inspection that this vector has four elements only, but you want to write your code in a way that is more broadly applicable. What if the data you are using your code in can have different lengths?

Hot tip: make your code generalizable even if it doesn't seem immediately necessary.

Instead of using `dna_sequences[4]` we could use `length(dna_sequences)` to index `dna_sequences`.

I have created a very long vector (I won't tell you how long!) called `dna_sequences2` and I want you to extract the last element of this vector and then print it, just as you did above. First extract the last element and place it an an object called `last_sequence`, then print the object.

```{r setupchrindex}
set.seed(1) 
dna_sequences2<-sapply(1:1000, function(x) paste0(sample(c("A","C","G","T"),4, replace=T), collapse=""))
```

```{r examplechrindex, exercise = TRUE, exercise.setup = "setupchrindex"}
                    
```

```{r examplechrindex-solution}
last_sequence <- dna_sequences2[length(dna_sequences2)]
print(last_sequence)
```

```{r examplechrindex-check}
grade_this_code()
```

### Example 5: Logical (also called boolean)

If you ask R is one object is the same as another, it will typically return a logical (boolean) object.

```{r, echo=T, eval=F}
a <- c(1,2,3) #suppose this is your data and you misenter the first number
b <- c(2,2,3) #and you want to make sure your data matches a previous result

```

In the space below, create an object called `which_entries_match` which contains the result of your asking if `a` is the same as `b`. In the second line, print the object your created remember from Lab 1 how we ask this in R. (Tip, it's not simply `a=b` because that will try to assign obect `b` to obkect `a`.)

```{r setupbool}
a <- c(1,2,3) 
b <- c(2,2,3)

```

```{r examplebool, exercise = TRUE, exercise.setup = "setupbool"}
           #create  which_entries_match 
           #print it
```

```{r examplebool-solution}
which_entries_match <- a == b
print(which_entries_match)
```

```{r examplebool-check}
grade_this_code()
```

## Data Structures

### Vectors

You already learned about vectors in the last lesson. They are a sequence of data elements of the same basic type. They can be numeric, integer, complex, character, or logical. They are **one-dimensional.**

R loves vectors and tends to treat everything like a vector: an object with only one element is a vector. E.g., `a<-9` is simply a vector of length `1`.

Check this is true by asserting object `a` is a vector using the function `is.vector`. Next, check its length with the function `length()`:

```{r setupvec1, echo=F}
a<-9

```

```{r examplevec1, exercise = TRUE, exercise.setup = "setupvec1"}
# use function is.vector on object a
#use function length on object a
                    
```

```{r examplevec1-solution}
is.vector(a) # use function is.vector on object a
length(a) #use function length on object a
```

```{r examplevec1-check}
grade_this_code()
```

### Matrices

A matrix in R is a **two-dimensional** data structure, where each element is of the **same type**. You can think of a matrix as a collection of vectors arranged side by side (for columns) or one on top of another (for rows). Here's an example of a numeric matrix.

```{r, echo=T, eval=F}
numeric_matrix <- matrix(seq(1:6), nrow = 2, ncol = 3) #create a matrix with numbers 1 through 6, with 2 rows and 3 columns
print(numeric_matrix)
dim(numeric_matrix) #gives dimensions of matrix. First value is number of rows, second value is number of columns.
```

Try these for yourself, play around with different numbers of rows and columns:

```{r sandbox9, exercise=TRUE, eval=F}

```

How do you index a matrix? Similar to what we learn for vectors, but now we have two instead of just one dimension.

```{r, echo=T, eval=F}
numeric_matrix[1,1] #select element in the 1st row and 1st column
numeric_matrix[2,3] #select element in the 2nd row and 3rd column
numeric_matrix[1,] #select entire 1st row
numeric_matrix[,3] #select entire 3rd column
```

You can also convert a vector that you made previously into a matrix.

```{r, echo=T, eval=F}
numeric_vector<-seq(1:6) #create vector with numbers 1:6
class(numeric_vector) #returns vector
as.matrix(numeric_vector)
numeric_matrix2<-as.matrix(numeric_vector, nrow=2, ncol=3) #converts numeric_vector into a matrix with [2,3] dimensions
```

Try these for yourself:

```{r sandbox10, exercise=TRUE, eval = FALSE}

```

Remember I created a very long vector before, called `dna_sequences2`? You will do the following: a) check the length of the vector; b) convert the vector into a matrix with 10 columns (don't specify the number of rows) and save this into object `dna_sequences2_mat`; c) use the `dim` function to figure out how many rows and columns the matrix has

```{r examplemat1, exercise = TRUE, exercise.setup = "setupchrindex"}
      # check length of dna_sequences2
      # convert dna_sequences2 into matrix with 10 columns
      # check dimensions of dna_sequences2_mat                
```

```{r examplemat1-solution}
length(dna_sequences2)
dna_sequences2_mat <- as.matrix(dna_sequences2, ncol=10)
dim(dna_sequences2_mat)
```

```{r examplemat1-check}
grade_this_code()
```

```{r, echo=T, eval=F}

```

Finally, what happens if you try to create a vector or a matrix with elements of different types? We can use the command `c` to concatenate different objects.

```{r, echo=T, eval=F}
a<-c(0, -5) #numeric
b<-c("ACGT", "TTGC") #character
d<-c(-1, 15000) #numeric
f<-"AGCT" #character
g<-2L #integer
h<-FALSE #logical
a_and_d<-c(a,d)  #numeric + numeric, no problems
b_and_f<-c(b, f) #character + character, no problems
a_and_g<-c(a,g)  # numeric + integer, oops?
a_and_b<-c(a,b) # numeric + charcter, oops
d_and_f<-c(d,f) #numeric + character, oops
d_and_g<-c(d, g) #numeric + integer, oops?
a_and_h<-c(a,h) # numeric + logical, oops
b_and_h<-c(b,h) # character + logical, oops

```

Try these for yourself  and observe the results before you move on. What type of data, if any, is provided with each combination. You can also try other combinations. Check the class of each of the objects created by concatenation.

```{r sandbox11, exercise=TRUE, eval = FALSE}

```

What you saw above was R trying to make sense of your mess. It "coerces" some of the values into another type so that your vector (or matrix) follows the rule of only one data type.

**Character Coercion:** If you concatenate objects of different types and one of them is a character, R will try to convert the non-character objects to characters. This often results in the character type because character data can accommodate a wide range of values. That's the case for `d_and_f` and `b_and_h`.

**Numeric Coercion:** If you concatenate objects of different types and one of them is numeric, R will try to convert the non-numeric objects to numeric. This is because numeric data can represent a broader range of values than other types. That's the case of `a_and_g` and `d_and_g`. The `integer` elements were coerced into numeric. If you try to coerce `numeric` and `logical`, the logical element becomes numeric. How? 0 is equivalent to `FALSE` and 1 is equivalent to `TRUE`. In fact, any number that is **not** zero will be considered `TRUE`. That's the case for `a_and_h`. Let's look at some more of this relstionship between numeric and Boolean variables below:

```{r, echo=T, eval=F}
#including only 0s and 1s
num_vec<-c(0,0,0,1,0,1,1,1,1,1,1,0)
num_log<-as.logical(num_vec) 
class(num_log)
#including other numbers
num_vec2<-c(0,0,0,2,3,4,1,1,0,0,0)
num_log2<-as.logical(num_vec2) 
class(num_log2)
#converting logical to number
log_vec<-c(FALSE, TRUE, TRUE, FALSE)
as.numeric(log_vec)
```

Try it!

```{r sandbox12, exercise=TRUE, eval = FALSE}

```

Everything we just said for vectors applies to matrices as well.

E.g., if you try to make a matrix composed of mixed elements.

```{r, echo=T, eval=F}
a<-c(0, -5) #numeric
b<-c("ACGT", "TTGC") #character
d<-c(-1, 15000) #numeric
f<-"AGCT" #character
g<-2L #integer
h<-FALSE #logical
mat1<-matrix(c(a, b))
class(mat1) #this tells you the data structure type (matrix)
typeof(mat1) #this tells you the the type of element the matrix contains. Note that this will result in coercion of numeric into character.
```

Try it!

```{r sandbox13, exercise=TRUE, eval = FALSE}

```

## Interaction between Vectors and Matrices:

As seen above, vectors and matrices interact in various ways in R. Here are a few examples:

-   You can create a matrix from vectors. Each vector can become a row or a column of the matrix.

-   You can extract a row or a column from a matrix as a vector.

-   You can use a vector to index a matrix, meaning to select certain rows or columns from the matrix.

-   You can perform arithmetic operations between a matrix and a vector. In this case, R will often apply the operation element-wise, meaning it will operate on each corresponding pair of elements from the matrix and the vector. If the vector is shorter than the matrix, R will recycle the elements of the vector to match the length of the matrix.

### Creating a matrix from vectors:

You can use the `cbind()` function to combine vectors as columns of a matrix, or `rbind()` to combine vectors as rows.

```{r matrix2, exercise = F }
# Create two vectors
vector1 <- c(1, 2, 3)
vector2 <- c(4, 5, 6)

# Combine vectors as columns to create a matrix
matrix1 <- cbind(vector1, vector2)

# Combine vectors as rows to create a matrix
matrix2 <- rbind(vector1, vector2)

```

Print them both to compare

```{r setupmat1}
vector1 <- c(1, 2, 3)
vector2 <- c(4, 5, 6)
matrix1 <- cbind(vector1, vector2)
matrix2 <- rbind(vector1, vector2)

```

```{r examplemat2, exercise = TRUE, exercise.setup = "setupmat1"}
                    
```

```{r examplemat2-solution}
print(matrix1)
print(matrix2)

```

```{r examplemat2-check}
grade_this_code()
```

### Performing arithmetic operations between a matrix and a vector:

R will apply the operation element-wise, and will recycle elements of the vector if necessary.

```{r mat3, exercise = F}
# Create a matrix
matrix4 <- matrix(1:6, nrow = 2)

# Create a vector
vector4 <- c(1, 2, 3)

# Add the vector to each row of the matrix
result4 <- matrix4 + vector4
```

```{r setupmat3}
matrix4 <- matrix(1:6, nrow = 2)
vector4 <- c(1, 2, 3)
result4 <- matrix4 + vector4

```

Print the result

```{r examplemat3, exercise = TRUE, exercise.setup = "setupmat3"}
                    
```

```{r examplemat3-solution}
print(result4)
```

```{r examplemat3-check}
grade_this_code()
```

## Other ways to store data

### Data Frames

A data frame in R is a table or a two-dimensional matrix-structure in which each column contains values of one variable and each row contains one set of values from each column. The data stored in a data frame can be of numeric, factor, or character type. You will use these a lot, this is just a brief introduction!

The key difference in relation to matrices is that different columns can have elements of different types.

```{r df1, exercise = F}
## Create a data frame that holds information about various species
species_info <- data.frame(
  "SpeciesName" = c("Panthera leo", "Gorilla gorilla", "Homo sapiens"),
  "CommonName" = c("Lion", "Gorilla", "Human"),
  "Family" = c("Felidae", "Hominidae", "Hominidae"),
  "GenomeSize" = c(2.8, 3.3, 3.2),  # in Giga Base Pairs
  "Diet" = c("Meat", "Herbivore", "Omnivore")
)



```

```{r setupdfex1}
# Create a data frame that holds information about various species
species_info <- data.frame(
  "SpeciesName" = c("Panthera leo", "Gorilla gorilla", "Homo sapiens"),
  "CommonName" = c("Lion", "Gorilla", "Human"),
  "Family" = c("Felidae", "Hominidae", "Hominidae"),
  "GenomeSize" = c(2.8, 3.3, 3.2),  # in Giga Base Pairs
  "Diet" = c("Meat", "Herbivore", "Omnivore")
)




```

In the space below: a) Print the dataframe and b) on the next row practice using the structure `dataframe$columnname` to select the column named "Family" and save that as a vector called "family". You can also use square brackets as seen for vectors and matrices but \$ allows you to see the name of the column you are extracting without counting which column you're interested in in the original dataframe.

```{r dfex1, exercise = TRUE, exercise.setup = "setupdfex1"}
                    
```

```{r dfex1-solution}
print(species_info)
family <- species_info$Family
```

```{r dfex1-check}
grade_this_code()
```

Dataframes are useful because they can combine multiple different types of data into a single object.

This is a dataset showing the hominin (early human) species name and hypothetical genome sizes for these early hominins (which we have no way of knowing yet).

```{r df2, exercise = F}
## Create a data frame that holds information about various species
species_info <- data.frame(
  "Genus" = c("Ardipithecus", "Australopithecus","Australopithecus","Australopithecus","Australopithecus","Australopithecus", "Homo","Homo","Homo","Homo","Homo","Homo","Homo","Paranthropus", "Paranthropus", "Sahelanthropus"),
  "Species" = c("ramidus", "afarensis", "africanus", "anamensis", "garhi", "sediba", "erectus", "floresiensis", "habilis", "heidelbergensis", "naledi", "rudolfensis", "sapiens","boisei", "robustus", "tchadensis"),
  "GenomSize" = c(2.80, 2.86, 2.90, 2.79, 3.48, 2.68, 3.29, 3.30, 3.11, 3.30, 2.80, 3.10, 3.25,3.17, 3.29, 3.01)  # in Giga Base Pairs
)



```

```{r setupdfex2}
## Create a data frame that holds information about various species
library(dplyr)
species_info <- data.frame(
  "Genus" = c("Ardipithecus", "Australopithecus","Australopithecus","Australopithecus","Australopithecus","Australopithecus", "Homo","Homo","Homo","Homo","Homo","Homo","Homo","Paranthropus", "Paranthropus", "Sahelanthropus"),
  "Species" = c("ramidus", "afarensis", "africanus", "anamensis", "garhi", "sediba", "erectus", "floresiensis", "habilis", "heidelbergensis", "naledi", "rudolfensis", "sapiens","boisei", "robustus", "tchadensis"),
  "GenomeSize" = c(2.80, 2.86, 2.90, 2.79, 3.48, 2.68, 3.29, 3.30, 3.11, 3.30, 2.80, 3.10, 3.25,3.17, 3.29, 3.01) # in Giga Base Pairs
)

australopithecus_genome_size<-dplyr::filter(species_info, Genus == "Australopithecus")

```

In the following box, seperate all the rows with "Australopithecus" in the `Genus` column using the function `filter` from the dplyr package. `dplyr` has a whole host of useful functions that make working with dataframes convenient. We will learn a lot more about the `dplyr` package in future lessons. Filter is just the tip of the iceberg.

Follow the format: `filter(dataframe_name, columnname == "Australopithecus")` and save the results as `australopithecus_genome_length`. Then, print `australopithecus_genome_length`.

```{r dfex2, exercise = TRUE, exercise.setup = "setupdfex2"}
                    
```

```{r dfex2-solution}
australopithecus_genome_size<-filter(species_info, Genus == "Australopithecus")
```

```{r dfex2-check}
grade_this_code()
```

Now, using the dataframe you made (`australopithecus_genome_size`), use the function `summary` on the column of that dataframe which contains the genome information to calculate how variable hominin genomes are. Save that result into the object `summary_results` and print out that object.

```{r dfex3, exercise = TRUE, exercise.setup = "setupdfex2"}
                    
```

```{r dfex3-solution}
summary_results <-summary(australopithecus_genome_size$GenomeSize)
print(summary_results)
```

```{r dfex3-check}
grade_this_code()
```

The summary function has a lot of interesting properties depending on the object type. In this case, because the column in question is numeric, it spits out some useful values like the minimum, maximum, mean, median, 1st, and 3rd quartile values.

### Lists

A list in R is an object that contains elements of different types - like numbers, strings, vectors, and even other lists. Lists are very flexible and are often used when data can't be held in other types of data structures. Different elements in a list can be of entirely different types.

```{r list1, exercise = F}
# Create a list that holds information about a species
species_info <- list(
  "SpeciesName" = "Panthera leo",
  "CommonName" = "Lion",
  "Family" = "Felidae",
  "GenomeSize" = 2.8,  # in Giga Base Pairs
  "Diet" = c("Meat")
)

```

```{r setuplist1}
# Create a list that holds information about a species
species_info <- list(
  "SpeciesName" = "Panthera leo",
  "CommonName" = "Lion",
  "Family" = "Felidae",
  "GenomeSize" = 2.8,  # in Giga Base Pairs
  "Diet" = c("Meat")
)


```

Print the result and use double square brackets -`[[]]` -to select the third item from the list

```{r list1ex, exercise = TRUE, exercise.setup = "setuplist1"}
                    #print the object
                    #select the 3rd element from the list
```

```{r list1ex-solution}
print(species_info)
species_info[[3]]
```

```{r list1ex-check}
grade_this_code()
```

Note: just like with dataframes, you can also use `$` to index a list based on the name of each element rather than its position.

### Arrays

An array in R is a multi-dimensionaldata structure for storing homogeneous data (i.e., data of the same type: numeric, logical, character, etc). In that way, it is similar to a matrix. It can be viewed as a multi-dimensional version of matrices. You can think of an array as a multi-dimensional table of data, with each dimension being a different attribute.

```{r array1, exercise = F}
# Create an array that holds gene expression data for 3 genes across 4 samples
gene_expression <- array(c(5,3,4,9,2,8,7,1,6,2,3,6,9, 7, 3, 1, 4, 3, 3, 7, 0, 2, 9, 4), dim = c(3,4,2))
dimnames(gene_expression) <- list(
  "Gene" = c("Gene1", "Gene2", "Gene3"),
  "Sample" = c("Sample1", "Sample2", "Sample3", "Sample4"),
  "Trials" = c("Trial1", "Trial2")
)


```

```{r setuparray1}
# Create an array that holds gene expression data for 3 genes across 4 samples
gene_expression <- array(c(5,3,4,9,2,8,7,1,6,2,3,6,9, 7, 3, 1, 4, 3, 3, 7, 0, 2, 9, 4), dim = c(3,4,2))
dimnames(gene_expression) <- list(
  "Gene" = c("Gene1", "Gene2", "Gene3"),
  "Sample" = c("Sample1", "Sample2", "Sample3", "Sample4"),
  "Trials" = c("Trial1", "Trial2")
)


```

Print the object:

```{r array1ex, exercise = TRUE, exercise.setup = "setuparray1"}
                    
```

```{r array1ex-solution}
print(gene_expression)
```

```{r array1ex-check}
grade_this_code()
```

Now, try and extract only the matrix which contains the data for trial 2. If you remember to extract columns and rows of a matrix we used the format `col <- matrix[,1]` and `row <- matrix[1,]` respectively. Arrays work the exact same way but because they are comprised of matrices that are glued together along the third dimension, you can call successive matrices as following: `matrix1 <- array[,,1]`, `matrix2 <- array[,,2]`, etc.

Save trial 2 as a new matrix named `trial2`.

```{r array1ex2, exercise = TRUE, exercise.setup = "setuparray1"}
                    
```

```{r array1ex2-solution}
trial2 <- gene_expression[,,2]
```

```{r array1ex2-check}
grade_this_code()
```

Arrays are useful, but niche data structures. A much more common type of data is a data frame.

## The final quiz

You've been tested throughout! This here is just graded for completion to check that you still remember everything.

The first part is basic questions like the tutorial. Feel free to go back to previous sections. You won't lose your progress unless you click "start over".

### 1-integer vector

Consider the following integer vector that represents the quantity of different species observed in a field study: `species_counts <- c(10, 20, 15, 30, 25)`. Let's say the researchers are particularly interested in species with observed counts of 20 or below.

Which species are of particular interest? First, create the vector `species_counts` and then use logical comparison to create a vector of TRUE/FALSE values indicating which species meet the criteria.

```{r numvecex, exercise = TRUE}
 #create vector
 # use logical statement
```

```{r numvecex-solution}
species_counts <- c(10, 20, 15, 30, 25)
species_counts <= 20
```

```{r numvecex-check}
grade_this_code()
```

### 2- list

You have a list that holds various information about a species, Is the species endangered? Use list indexing (with `$`) to retrieve the information.

```{r listexam, exercise = TRUE}
species_info_list <- list("SpeciesName" = "Panthera leo", "Population" = 20000, "Endangered" = TRUE)       


```

```{r listexam-solution}
species_info_list <- list("SpeciesName" = "Panthera leo", "Population" = 20000, "Endangered" = TRUE)
species_info_list$Endangered
```

```{r listexam-check}
grade_this_code()
```

### 3- cbind/rbind

You have two vectors representing the diameters of two different types of cells observed under a microscope. Combine these two vectors into a matrix where each column represents a different cell type. Name the matrix `cell_diameters` and then print it.

```{r bindex1, exercise = TRUE}
cell1_diameters <- c(10, 12, 11, 13, 12)  
cell2_diameters <- c(15, 17, 16, 18, 17)
      #create object cell_diameters
      #print it
```

```{r bindex1-solution}
cell1_diameters <- c(10, 12, 11, 13, 12)  
cell2_diameters <- c(15, 17, 16, 18, 17)
cell_diameters<-cbind(cell1_diameters, cell2_diameters)
print(cell_diameters)
```

```{r bindex1-check}
grade_this_code()

```

You have two vectors representing the heights of two different types of plants measured in a field study. Combine these two vectors into a matrix where each row represents a different plant type. Name the matrix `plant_heights` and then print it.

```{r bindex2, exercise = TRUE}
plant1_heights <- c(100, 120, 110, 130, 120) 
plant2_heights <- c(150, 170, 160, 180, 170)
            #create `plant_heights`
             #print it
```

```{r bindex2-solution}
plant1_heights <- c(100, 120, 110, 130, 120) 
plant2_heights <- c(150, 170, 160, 180, 170)
plant_heights<-rbind(plant1_heights, plant2_heights)
print(plant_heights)
```

```{r bindex2-check}
grade_this_code()
```

## Quiz Part 2: Working with real data

Now we are going to practice working with an actual data set. We will be using one from the `datasets` package called `chickweights`. It's from an experiment on the effect of diet on early growth of chicks. If you want to learn more about the dataset type ??chickweights into your console (later, now while you are taking this quiz!)

### Lets look at the data

The datasets package already has the data stored as a data frame. If it wasn't you could call data.frame to turn it into one. Rename the data `chicks` by assigning the code already loaded to that name. It's long, so we don't want to print the whole thing. Use a specific function called `head` to call just the first 6 rows of the object.

```{r chicks1, exercise = TRUE}

            # create chicks object
```

```{r chicks1-solution}
chicks<-datasets::ChickWeight
head(chicks)
```

```{r chicks1-check}
grade_this_code()
```

### Analyzing the data

Lets see which diet worked best! This data shows us the same chicken at multiple times. If we only want to see the final outcome, we can filter for the final weight. Using the `dplyr` package's `filter` function to select only chicks with time 21 from the `chicks` object. name this resulting dataframe `FinalChicks`. Then print it.

```{r setupchicks}
chicks<-datasets::ChickWeight

```

```{r setupchicks2}
chicks<-datasets::ChickWeight
FinalChicks<-filter(chicks, Time == "21")
```

```{r chicks2, exercise = TRUE, exercise.setup = "setupchicks"}
            #select only chicks with time 21 from the chicks object and call it FinalChicks
            #print it
```

```{r chicks2-solution}
FinalChicks<-filter(chicks, Time == 21)
print(FinalChicks)
```

```{r chicks2-check}
grade_this_code()
```

Now lets get the mean for each diet. Use the pattern below calculate the mean weight for the chicks in each of the 4 diets.

```{r chicks3, exercise = TRUE, exercise.setup = "setupchicks2"}
diet1<-filter(chicks, Diet == "1")
mean(diet1$weight)
                                  #diet 2
                                  #diet 3
                                  #diet 4
```

```{r chicks3-solution}
diet1<-filter(chicks, Diet == "1")
mean(diet1$weight)

diet2<-filter(chicks, Diet == "2")
mean(diet2$weight)

diet3<-filter(chicks, Diet == "3")
mean(diet3$weight)

diet4<-filter(chicks, Diet == "4")
mean(diet4$weight)

```

```{r chicks3-check}
grade_this_code()
```

Isn't that a lot of work to get 4 simple means? Next week you are going to learn how to do all that in one go! Here's how you'd do it. Print the dataframe from this code to see how fast it is!

```{r chicks4, exercise = TRUE, exercise.setup = "setupchicks"}
avg_chick_wgts<- chicks %>%
filter(Time == "21") %>% 
group_by(Diet) %>%
summarize(mean_weight = mean(weight, na.rm = TRUE))


      #print it
```

```{r chicks4-solution}
avg_chick_wgts<- chicks %>%
filter(Time == "21") %>% 
group_by(Diet) %>%
summarize(mean_weight = mean(weight, na.rm = TRUE))

print(avg_chick_wgts)
```

```{r chicks4-check}
grade_this_code()
```

### Coercion, rbind, cbind

Suppose you ran the following code.

```{r, echo=T, eval=F}
chickID<- c(4,  39, 16, 43, 10, 11, 12, 49, 28, 6)
dead<- c(TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE)
result<-rbind(chickID, dead) #this is a matrix
```

```{r quiz-question, echo=FALSE}
#this chunk is giving me a hard time
learnr::quiz(caption="",
  question("Which of the following statements is correct?",
    answer("`result` has 10 rows and 2 columns."),
    answer("Row 2 of `result` will be: `TRUE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, TRUE`"),
    answer("The output of `result[1,1]` is 4.", correct=TRUE),
   allow_retry = TRUE))
```

## The end!

-   username is what comes before your `@brynmawr.edu` or `@haverford.edu`.
-   password if b215f23

```{r, echo=F}
#submitr::login_controls()
```
